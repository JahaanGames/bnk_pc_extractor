/**
 * bnk_pc_packer.c - a simple packer of .bnk_pc files found in Saints
 * Row: The Third. Depends on extracting metadata from archives first.
 *
 * Copyright (c) 2011 Michael Lelli
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "bnk_pc.h"

#define PADDING_LENGTH 0x800

const static u8 padding[PADDING_LENGTH] = { 0 };

void padFile(FILE *f)
{
	fwrite(padding, PADDING_LENGTH - (ftell(f) % PADDING_LENGTH), 1, f);
}

int main(int argc, char *argv[])
{
	FILE *f = NULL;
	FILE *out = NULL;
	FILE *sb = NULL;
	u32 i;
	header head;
	entry *entries = NULL;
	int r = 0;
	char name[1024];
	char soundboot[1024];

	if (argc > 4)
	{
		f = fopen(argv[1], "r");

		if (f == NULL)
		{
			printf("log file %s can't be opened\n", argv[1]);
			goto error;
		}
	}
	else
	{
		printf("bnk_pc_packer " VERSION "\n"
		       "usage: %s log.txt file1.wav file2.wav ... output.bnk_pc\n"
		       "log.txt is generated by bnk_pc_extractor\n"
		       "if packing dmav/wav combo files, list the .wav or .bin files, and the .dmav\n"
		       "counterpart will be added automatically\n", argv[0]);
		goto error;
	}

	memcpy(name, argv[argc - 1], strlen(argv[argc - 1]) + 1);
	name[strrchr(name, '.') - name] = 0;

	head.magic = 0x2020435042535756ULL;

	fscanf(f, "HEADER:\n");
	fscanf(f, "magic:  \"VWSBPC  \"\n");
	fscanf(f, "k1:     0x%08X\n", &(head.k1));
	fscanf(f, "k2:     0x%08X\n", &(head.k2));
	fscanf(f, "id:     0x%08X\n", &(head.id));
	fscanf(f, "k3:     0x%08X\n", &(head.k3));
	fscanf(f, "count:  0x%08X\n", &(head.count));

	if (head.count != argc - 3)
	{
		printf("expected %d files, got %d\n", head.count, argc - 3);
		goto error;
	}

	out = fopen(argv[argc - 1], "wb");
	fwrite(&head, sizeof(header), 1, out);
	entries = malloc(sizeof(entry) * head.count);

	// loop 1: go through the log file and get the unknown metadata
	for (i = 0; i < head.count; i++)
	{
		unsigned int temp;

		fscanf(f, "\n%05u:\n", &temp);

		if (i != temp)
		{
			printf("entry count miss-match: expected %u, got %u\n", i, temp);
			goto error;
		}

		fscanf(f, "id:     0x%08X\n", &(entries[i].id));
		fscanf(f, "offset: 0x%08X\n", &(entries[i].offset));
		fscanf(f, "dmav:   0x%08X\n", &(entries[i].dmav));
		fscanf(f, "length: 0x%08X\n", &(entries[i].length));

		// write 0's for now, will come back and write actuall data later
		fwrite(padding, sizeof(entry), 1, out);
	}

	padFile(out);

	// loop 2: insert data
	for (i = 0; i < head.count; i++)
	{
		FILE *in;
		u8 *buffer;
		char _filename[1024];
		char filename[1024];
		entries[i].offset = ftell(out);

		if (entries[i].dmav)
		{
			memcpy(_filename, argv[i + 2], strlen(argv[i + 2]) + 1);
			_filename[strrchr(_filename, '.') - _filename] = 0;
			sprintf(filename, "%s.dmav", _filename);
			in = fopen(filename, "rb");

			if (in == NULL)
			{
				printf("could not open DMAV %s for reading\n", filename);
				goto error;
			}

			fseek(in, 0, SEEK_END);

			if(ftell(in) != entries[i].dmav)
			{
				printf("DMAV (%s) wrong size; got %d, should be %d\n", filename, ftell(in), entries[i].dmav);
				fclose(in);
				goto error;
			}

			fseek(in, 0, SEEK_SET);
			buffer = malloc(entries[i].dmav);
			fread(buffer, entries[i].dmav, 1, in);
			fclose(in);
			fwrite(buffer, entries[i].dmav, 1, out);
		}

		in = fopen(argv[i + 2], "rb");

		if (in == NULL)
		{
			printf("could not open %s for reading\n", argv[i + 2]);
			goto error;
		}

		fseek(in, 0, SEEK_END);
		entries[i].length = ftell(in);
		fseek(in, 0, SEEK_SET);
		buffer = malloc(entries[i].length);
		fread(buffer, entries[i].length, 1, in);
		fclose(in);
		fwrite(buffer, entries[i].length, 1, out);
		free(buffer);

		padFile(out);
	}

	// loop 3: go back and write updated entries

	fseek(out, sizeof(header), SEEK_SET);
	fwrite(entries, sizeof(entry), head.count, out);
	sprintf(soundboot, "%s.mbnk_pc", name);
	sb = fopen(soundboot, "wb");
	fwrite(&head, sizeof(header), 1, sb);
	fwrite(entries, sizeof(entry), head.count, sb);

end:
	free(entries);

	if (f != NULL)
	{
		fclose(f);
	}

	if (out != NULL)
	{
		fclose(out);
	}

	if (sb != NULL)
	{
		fclose(sb);
	}

	return r;

error:
	r = 1;
	goto end;
}
