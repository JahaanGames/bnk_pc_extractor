/**
 * bnk_pc_packer.c - a simple packer of .bnk_pc files found in Saints
 * Row: The Third. Depends on extracting metadata from archives first.
 *
 * Copyright (c) 2011 Michael Lelli
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "bnk_pc.h"

#define is_whitespace(x) ((x) == '\n' || (x) == '\r' || (x) == '\t' || (x) == ' ')

#define PADDING_LENGTH 0x800

static const u8 padding[PADDING_LENGTH] = { 0 };

void padFile(FILE *f)
{
	fwrite(padding, PADDING_LENGTH - (ftell(f) % PADDING_LENGTH), 1, f);
}

int main(int argc, char *argv[])
{
	FILE *f = NULL;
	FILE *out = NULL;
	FILE *sb = NULL;
	u32 i;
	header head;
	entry *entries = NULL;
	int r = 0;
	char name[1024];
	char soundboot[1024];
	char **filenames = NULL;

	if (argc != 3)
	{
		printf("bnk_pc_packer " VERSION "\n"
		       "usage: %s log.txt output.bnk_pc\n"
		       "log.txt is generated by bnk_pc_extractor, file filenames edited accordingly\n"
		       "only filename, id, dmav field are used in packing, the rest are recalculated\n"
		       "if packing dmav/wav combo files, the .dmav counterpart will be added\n"
		       "automatically\n", argv[0]);
		goto error;
	}

	f = fopen(argv[1], "r");

	if (f == NULL)
	{
		printf("log file %s can't be opened\n", argv[1]);
		goto error;
	}

	head.magic = BNK_PC_HEADER;

	fscanf(f, "ONLY EDIT THE FILENAMES\n");
	fscanf(f, "HEADER:\n");
	fscanf(f, "magic:  \"VWSBPC  \"\n");
	fscanf(f, "k1:     0x%08X\n", &(head.k1));
	fscanf(f, "k2:     0x%08X\n", &(head.k2));
	fscanf(f, "id:     0x%08X\n", &(head.id));
	fscanf(f, "k3:     0x%08X\n", &(head.k3));
	fscanf(f, "count:  0x%08X\n", &(head.count));

	out = fopen(argv[2], "wb");
	fwrite(&head, sizeof(header), 1, out);
	entries = calloc(head.count, sizeof(entry));
	filenames = calloc(head.count, sizeof(char*));

	// loop 1: go through the log file and get the unknown metadata
	for (i = 0; i < head.count; i++)
	{
		unsigned int temp;
		u32 j;
		char _filename[1024];
		char *filename = _filename;

		fscanf(f, "\n%05u:", &temp);

		if (i != temp)
		{
			printf("entry count miss-match: expected %u, got %u\n", i, temp);
			goto error;
		}

		// needed for filenames with spaces
		fgets(_filename, sizeof(_filename), f);

		for (j = strlen(_filename) - 1; j > 0; j--)
		{
			if (is_whitespace(_filename[j]))
			{
				_filename[j] = 0;
			}
			else
			{
				break;
			}
		}

		for (j = 0; j < strlen(_filename); j++)
		{
			if (!is_whitespace(_filename[j]))
			{
				filename = &(_filename[j]);
				break;
			}
		}

		fscanf(f, "id:     0x%08X\n", &(entries[i].id));
		fscanf(f, "offset: 0x%08X\n", &(entries[i].offset));
		fscanf(f, "dmav:   0x%08X\n", &(entries[i].dmav));
		fscanf(f, "length: 0x%08X\n", &(entries[i].length));

		filenames[i] = calloc(strlen(filename) + 1, sizeof(char));
		memcpy(filenames[i], filename, strlen(filename) + 1);

		// write 0's for now, will come back and write actuall data later
		fwrite(padding, sizeof(entry), 1, out);
	}

	padFile(out);

	// loop 2: insert data
	for (i = 0; i < head.count; i++)
	{
		FILE *in;
		u8 *buffer;
		char _dmavname[1024];
		char dmavname[1024];
		entries[i].offset = ftell(out);

		if (entries[i].dmav != 0)
		{
			u32 tell;
			memcpy(_dmavname, filenames[i], strlen(filenames[i]) + 1);
			_dmavname[strrchr(_dmavname, '.') - _dmavname] = 0;
			sprintf(dmavname, "%s.dmav", _dmavname);
			in = fopen(dmavname, "rb");

			if (in == NULL)
			{
				printf("could not open DMAV %s for reading\n", dmavname);
				goto error;
			}

			fseek(in, 0, SEEK_END);
			tell = ftell(in);

			if(tell != entries[i].dmav)
			{
				printf("DMAV (%s) wrong size; got %d, should be %d\n", dmavname, tell, entries[i].dmav);
				fclose(in);
				goto error;
			}

			fseek(in, 0, SEEK_SET);
			buffer = malloc(entries[i].dmav);
			fread(buffer, entries[i].dmav, 1, in);
			fclose(in);
			fwrite(buffer, entries[i].dmav, 1, out);
			free(buffer);
		}

		in = fopen(filenames[i], "rb");

		if (in == NULL)
		{
			printf("could not open %s for reading\n", filenames[i]);
			goto error;
		}

		fseek(in, 0, SEEK_END);
		entries[i].length = ftell(in);
		fseek(in, 0, SEEK_SET);
		buffer = malloc(entries[i].length);
		fread(buffer, entries[i].length, 1, in);
		fclose(in);
		fwrite(buffer, entries[i].length, 1, out);
		free(buffer);

		padFile(out);
	}

	// loop 3: go back and write updated entries
	fseek(out, sizeof(header), SEEK_SET);
	fwrite(entries, sizeof(entry), head.count, out);

	memcpy(name, argv[2], strlen(argv[2]) + 1);
	name[strrchr(name, '.') - name] = 0;
	sprintf(soundboot, "%s.mbnk_pc", name);
	sb = fopen(soundboot, "wb");
	fwrite(&head, sizeof(header), 1, sb);
	fwrite(entries, sizeof(entry), head.count, sb);

end:
	free(entries);

	if (filenames != NULL)
	{
		for (i = 0; i < head.count; i++)
		{
			free(filenames[i]);
		}

		free(filenames);
	}

	if (f != NULL)
	{
		fclose(f);
	}

	if (out != NULL)
	{
		fclose(out);
	}

	if (sb != NULL)
	{
		fclose(sb);
	}

	return r;

error:
	r = 1;
	goto end;
}
